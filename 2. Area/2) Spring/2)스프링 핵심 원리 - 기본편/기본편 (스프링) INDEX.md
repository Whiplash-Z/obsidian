- [[객체 지향 설계와 스프링]]: 스프링을 사용해야 하는 이유
	- 다형성만으로는 OCP, DIP 원칙을 지키는데 한계가 있다.
		- 이 문제를 해결하기 위해서는 **"객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다."**
			- **이걸 스프링(스프링 컨테이너)이 해주는 것이다.**
			- **이 원칙을 지키기 위해서 DI, IOC컨테이너가 필요하다.**
	- 스프링은 **객체 지향 언어가 가진 강력한 특징**을 살려내는 프레임워크.
	- 스프링은 **다형성을 극대화**해서 이용할 수 있게 도와준다.
- [[스프링 핵심 원리]]
	- OCP, DIP를 위배하는 예제 [[스프링 핵심 원리#^notOCPandDIP]]
	- 관심사를 분리해서 문제점 해결 [[스프링 핵심 원리#^canOCPandDIP]]
	- 관심사의 분리로 인한 장점 [[스프링 핵심 원리#^separationOfinterests]]
		- 설계 변경으로 **구현체를 의존하지 않는다.**
		- 단지 **인터페이스만 의존**한다.
		- 구현체 입장에서 생성자를 통해 **어떤 구현 객체가 들어올지(주입될지) 알 수 없다.**
		- 생성자를 통해 **어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에서 결정된다.**
		- 구현체는 이제부터 **의존관계에 대한 고민은 외부**에 맡기고 **실행에만 집중**하면 된다.
- [[싱글톤 컨테이너]]
	- 스프링 컨테이너 생성 과정
		1. 스프링컨테이너 생성(`new AnnotationConfigApplicationContext(AppConfig.class)`)
		2. 스프링 빈 등록(`@Bean`)
		3. 스프링 빈 의존관계 설정 준비
		4. 스프링 빈 의존관계 설정 완료
	- 싱글톤 컨테이너
		- **호출마다 새로운 인스턴스가 생성되는 문제** 해결 방법
		  [[스프링 핵심 원리#^createInstanceTwoTimes]]
		- 싱글톤: 객체가 현재 java JVM 안에 **객체 인스턴스가 딱 하나만** 있어야 하는 패턴
	- 싱글톤 방식의 주의점
		- 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 **무상태(stateless)로 설계해야 한다.**
	- @Configuration과 싱글톤
		- 스프링 컨테이너는 어떻게 싱글톤을 보장할까?
			- 여러번 호출 ❌, 한 번만 호출 ⭕️
			- `@Configuration`[[싱글톤 컨테이너#^CGLIB]]
				- 스프링이 **CGLIB**라는 **바이트코드 조작 라이브러리를 사용**
				- **임의의 다른 클래스를 만들고 이를 스프링 빈으로 등록**
				- **이 임의의 다른 클래스가 싱글톤이 보장**
		- @Configuration을 적용하지 않고 **@Bean만 적용한다면?**
			- @Bean만 사용해도 스프링 빈으로 등록되지만, **싱글톤을 보장하지 않는다.**
			- CGLIB 기술 없이 **순수한** AppConfig로 스프링 빈에 등록
			- **각각 다른 인스턴스를 생성**
	- [[의존관계 자동 주입]]
		- 컴포넌트 스캔
			- `@ComponentScan`은 `@Component`가 붙은 **모든 클래스를 스프링 빈으로 등록**한다.
				- 설정 정보에 **@Bean을 매번 입력해줄 필요가 없다.**
			- 생성자에 `@Autowired`를 지정하면, 스프링 컨테이너가 **자동으로 해당 스프링 빈을 찾아서 주입**한다.
				- **생성자에 파라미터가 많아도 다 찾아서 자동으로 주입**한다.
			- **기본 조회 전략**은 **타입이 같은 빈을 찾아서 주입**한다.
		- 생성자 주입을 선택해라 !
			- 불변
				- 대부분의 의존관계는 애플리케이션 종료 전까지 변경하면 안된다.
				- 수정자 주입 -> 변경 가능성 존재(public method) -> 잘못된 설계
			- 누락
				- **생성자 주입을 사용하면** 주입 데이터를 **누락했을 때** **컴파일 오류가 발생**한다.
				- 생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있다.
					- 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.
		- 롬복과 최신 트랜드: `@RequiredArgsConstructor`
		- 조회 빈이 2개 이상 시 발생했을 때 해결 방법
			- @Autowired 필드명 매칭
			- @Qualifier -> @Qualifier끼리 매칭 -> 빈 이름 매칭
				![[Pasted image 20241118195125.png]]![[Pasted image 20241118195213.png]]
			- @Primary 사용
				- @Primary 는 우선순위를 정하는 방법이다.
					![[Pasted image 20241118195403.png]]
		- 스프링 빈의 이벤트 라이프사이클
			- 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백(**@PostConstruct**) -> 사용 -> (**@PreDestroy**)소멸전 콜백 -> 스프링 종료
		- 빈 스코프
			- 스프링 빈은 기본적으로 **싱클톤 스코프로 생성**된다.
				- 스프링 컨테이너의 시작 ~ 종료까지 스프링 빈이 유지된다.
			- 스코프 지원 종류
				- 싱글톤: 스프링 컨테이너의 시작 ~ 종료까지 유지
					- @Scope("singleton): 같은 객체 인스턴스의 스프링 빈을 반환
				- 프로토타입: 프로토타입 빈의 생성과 의존관계 주입까지만 관여
					- @Scope("prototype): 항상 새로운 인스턴스의 프로토타입 빈을 반환
					- 스프링 컨테이너는 **프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리**한다.
					- 클라이언트에 프로토타입 빈을 반환하고, 이후 스프링컨테이너는 생성된 프로토타입 빈을 **관리하지 않는다.**
					- @PreDestroy 같은 종료 메서드가 호출되지 않는다.
					  (클라이언트가 직접 종료 메서드를 호출해야 한다.)
				  - 싱글톤 빈과 프로토타입 빈을 함께 사용할 때 항상 새로운 프로토타입 빈을 생성할 때는 Provider를 사용한다. `ObjectProvider`
					  - `ObjectProvider.getObject()`를 **호출하는 시점까지 빈의 생성을 지연**할 수 있다. -> 프록시를 사용해서 싱글톤 빈을 사용하듯 편리하게 request scope를 사용하게 할 수 있다.
					    **(진짜 객체 조회를 꼭 필요한 시점까지 지연처리한다.)**
					  - 매번 사용할 때 마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용하면 된다.
				- 웹
					- request: 웹 요청이 들어오고 나갈때 까지
					- session: 웹 세션이 생성되고 종료될때 까지
					- application: 웹의 서블릿 컨텍스트와 같은 범위로 유지
					- websocket: 웹 소켓과 동일한 생명주기
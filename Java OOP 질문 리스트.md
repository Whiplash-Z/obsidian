## **✅ [a) 자바의 객체지향 언어를 사용하는 이유]**

  

### **📌 질문 요약**

- 왜 Java는 객체지향 언어로 설계되었는가?
    
- 절차지향 언어와 어떤 차이가 있는가?
    

  

### **💡 핵심 개념 정리**

- **절차지향**: 함수 중심, 순서대로 처리. 데이터가 함수로부터 독립적이지 못함.
    
- **객체지향**: 데이터와 메서드를 하나로 묶어 관리(=캡슐화), **재사용성, 확장성, 유지보수성** 뛰어남.
    
- Java는 복잡한 시스템을 잘 구조화할 수 있게 하기 위해 객체지향 기반으로 설계됨.
    

---

## **✅ [b) 클래스와 데이터]**

  

### **📌 질문 요약**

- 데이터를 나눠서 관리하지 않으면 어떤 문제가 발생하는가?
    

  

### **💡 핵심 개념 정리**

- 데이터를 구조화하지 않으면 **의미 없는 나열**이 됨 → 개발자가 관리하기 어려움
    
- 클래스를 통해 관련 데이터(필드)와 동작(메서드)을 묶어서 **더 명확하게 표현** 가능
    

---

## **✅ [c) 기본형과 참조형]**

  

### **📌 질문 요약**

- 기본형과 참조형의 메모리 저장 위치 차이는?
    
- 참조형은 실제 어떤 흐름으로 주소를 가리키는가?
    

  

### **💡 핵심 개념 정리**

- **기본형(primitive)**: int, double 등 → **값 자체를 스택에 저장**
    
- **참조형(reference)**: 배열, 객체 등 → **스택에는 참조 주소**, **실제 값은 힙에 저장**
    
- JVM이 스택/힙 영역을 통해 값을 효율적으로 관리
    

---

## **✅ [d) 객체지향 프로그래밍 (OOP)]**

  

### **📌 질문 요약**

- 캡슐화란 무엇인가?
    
- 속성과 기능이 하나로 묶인다는 게 무슨 의미?
    

  

### **💡 핵심 개념 정리**

- **캡슐화**란 데이터와 메서드를 하나의 클래스에 묶는 것
    
- 외부에서 직접 접근하지 못하게 하고, **메서드를 통해 제어**함
    
- 코드의 **안정성, 재사용성, 유지보수성** 향상
    

---

## **✅ [e) 자바 메모리 구조와 static]**

  

### **📌 질문 요약**

- 메서드 영역, 스택, 힙에 각각 무엇이 저장되는가?
    
- static 변수는 왜 인스턴스 없이도 접근 가능한가?
    
- 지역 변수는 왜 초기화하지 않으면 컴파일 에러가 나는가?
    

  

### **💡 핵심 개념 정리**

- **메서드 영역**: 클래스, static 변수, 메서드 정보
    
- **스택 영역**: 호출된 메서드의 지역 변수, 매개 변수
    
- **힙 영역**: 생성된 객체(인스턴스) 저장
    
- static은 **클래스 로딩 시 메서드 영역에 저장**되므로 인스턴스 없이 접근 가능
    
- 지역 변수는 **JVM이 초기화하지 않기 때문에** 컴파일 타임에서 강제적으로 초기화 필요
    

---

## **✅ [f) 상속]**

  

### **📌 질문 요약**

- 부모 클래스의 메서드, 필드는 어떻게 상속되나?
    
- 생성자는 왜 상속이 안 되나?
    
- 자식 생성자에서 super는 왜 첫 줄에 위치해야 하나?
    

  

### **💡 핵심 개념 정리**

- 상속은 코드 재사용을 위한 핵심 기능
    
- **생성자는 상속되지 않음**, 하지만 자식 객체를 만들기 위해 **반드시 부모 생성자 먼저 호출**
    
- super()는 **자식 생성자의 가장 첫 줄에 위치**해야 컴파일이 가능
    
- 접근 제어자 private, package-private는 자식 클래스에서 직접 접근 불가
    

---

## **✅ [g) 다형성]**

  

### **📌 질문 요약**

- 오버라이딩된 메서드가 호출되는 이유는?
    
- 업캐스팅/다운캐스팅이 왜 필요한가?
    
- instanceof는 언제 쓰는가?
    

  

### **💡 핵심 개념 정리**

- **다형성(polymorphism)**: 하나의 타입으로 여러 구현을 다룰 수 있는 성질
    
- 부모 타입으로 자식 객체를 참조할 수 있고(업캐스팅), 필요 시 원래 타입으로 변환(다운캐스팅)
    
- 오버라이딩된 메서드는 **실행 시점(run-time)**에 자식 객체 기준으로 동작
    
- **instanceof**는 실제 타입을 체크해 다운캐스팅 안전성을 확보
    

---

## **✅ [h) 다형성 활용: 추상 클래스와 인터페이스]**

  

### **📌 질문 요약**

- 추상 클래스와 인터페이스의 차이는?
    
- 추상 클래스의 일반 메서드는 오버라이딩 가능한가?
    
- 멤버 변수는 어떻게 선언되고 어떤 제약이 있는가?
    

  

### **💡 핵심 개념 정리**

- **추상 클래스**: 일부 구현 + 일부 추상 메서드 포함 가능 → 확장 가능하지만 **단일 상속**
    
- **인터페이스**: 모든 메서드가 추상(= 구현 없어야 함), 다중 구현(= 다중 상속) 가능
    
- 인터페이스의 멤버 변수는 **무조건 public static final**
    
- 인터페이스는 **계약(Contract)을 표현**하고, 실제 구현은 클래스가 담당
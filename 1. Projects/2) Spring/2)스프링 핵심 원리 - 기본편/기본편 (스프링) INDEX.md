- [[객체 지향 설계와 스프링]]: 스프링을 사용해야 하는 이유
	- 다형성만으로는 OCP, DIP 원칙을 지키는데 한계가 있다.
		- 이 문제를 해결하기 위해서는 **"객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다."**
			- **이걸 스프링(스프링 컨테이너)이 해주는 것이다.**
			- **이 원칙을 지키기 위해서 DI, IOC컨테이너가 필요하다.**
	- 스프링은 **객체 지향 언어가 가진 강력한 특징**을 살려내는 프레임워크.
	- 스프링은 **다형성을 극대화**해서 이용할 수 있게 도와준다.
- [[스프링 핵심 원리]]
	- OCP, DIP를 위배하는 예제 [[스프링 핵심 원리#^notOCPandDIP]]
	- 관심사를 분리해서 문제점 해결 [[스프링 핵심 원리#^canOCPandDIP]]
	- 관심사의 분리로 인한 장점 [[스프링 핵심 원리#^separationOfinterests]]
		- 설계 변경으로 **구현체를 의존하지 않는다.**
		- 단지 **인터페이스만 의존**한다.
		- 구현체 입장에서 생성자를 통해 **어떤 구현 객체가 들어올지(주입될지) 알 수 없다.**
		- 생성자를 통해 **어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에서 결정된다.**
		- 구현체는 이제부터 **의존관계에 대한 고민은 외부**에 맡기고 **실행에만 집중**하면 된다.
- [[싱글톤 컨테이너]]
	- 스프링 컨테이너 생성 과정
		1. 스프링컨테이너 생성(`new AnnotationConfigApplicationContext(AppConfig.class)`)
		2. 스프링 빈 등록(`@Bean`)
		3. 스프링 빈 의존관계 설정 준비
		4. 스프링 빈 의존관계 설정 완료
	- 싱글톤 컨테이너
		- **호출마다 새로운 인스턴스가 생성되는 문제** 해결 방법
		  [[스프링 핵심 원리#^createInstanceTwoTimes]]
		- 싱글톤: 객체가 현재 java JVM 안에 **객체 인스턴스가 딱 하나만** 있어야 하는 패턴
	- 싱글톤 방식의 주의점
		- 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 **무상태(stateless)로 설계해야 한다.**
	- @Configuration과 싱글톤
		- 스프링 컨테이너는 어떻게 싱글톤을 보장할까?
			- 여러번 호출 X, 한 번만 호출 ⭕️
			- `@Configuration`[[싱글톤 컨테이너#^CGLIB]]
				- 스프링이 **CGLIB**라는 **바이트코드 조작 라이브러리를 사용**
				- **임의의 다른 클래스를 만들고 이를 스프링 빈으로 등록**
				- **이 임의의 다른 클래스가 싱글톤이 보장**
		- @Configuration을 적용하지 않고 @Bean만 적용한다면?
			- @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다.
			- CGLIB 기술 없이 순수한 AppConfig로 스프링 빈에 등록
			- 매번 각각 다른 인스턴스를 생성
	- 컴포넌트 스캔
	- 의존관계 자동 주입
	- 빈 생명주기 콜백
	- 빈 스코프
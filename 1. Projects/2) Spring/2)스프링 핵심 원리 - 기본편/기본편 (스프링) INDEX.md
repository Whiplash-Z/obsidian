- [[객체 지향 설계와 스프링]]: 스프링을 사용해야 하는 이유
	- 다형성만으로는 OCP, DIP 원칙을 지키는데 한계가 있다.
		- 이 문제를 해결하기 위해서는 **"객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다."**
			- **이걸 스프링(스프링 컨테이너)이 해주는 것이다.**
			- **이 원칙을 지키기 위해서 DI, IOC컨테이너가 필요하다.**
	- 스프링은 **객체 지향 언어가 가진 강력한 특징**을 살려내는 프레임워크.
	- 스프링은 **다형성을 극대화**해서 이용할 수 있게 도와준다.
- [[스프링 핵심 원리]]
	- OCP, DIP를 위배하는 예제 [[스프링 핵심 원리#^notOCPandDIP]]
	- 관심사를 분리해서 문제점 해결 [[스프링 핵심 원리#^canOCPandDIP]]
	- 관심사의 분리로 인한 장점 [[스프링 핵심 원리#^separationOfinterests]]
		- 설계 변경으로 **구현체를 의존하지 않는다.**
		- 단지 **인터페이스만 의존**한다.
		- 구현체 입장에서 생성자를 통해 **어떤 구현 객체가 들어올지(주입될지) 알 수 없다.**
		- 생성자를 통해 **어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에서 결정된다.**
		- 구현체는 이제부터 **의존관계에 대한 고민은 외부**에 맡기고 **실행에만 집중**하면 된다.
- [[싱글톤 컨테이너]]
	- 스프링 컨테이너 생성 과정
		1. 스프링컨테이너 생성(`new AnnotationConfigApplicationContext(AppConfig.class)`)
		2. 스프링 빈 등록(`@Bean`)
		3. 스프링 빈 의존관계 설정 준비
		4. 스프링 빈 의존관계 설정 완료
	- 싱글톤 컨테이너
		- **호출마다 새로운 인스턴스가 생성되는 문제** 해결 방법
		  [[스프링 핵심 원리#^createInstanceTwoTimes]]
		- 싱글톤: 객체가 현재 java JVM 안에 **객체 인스턴스가 딱 하나만** 있어야 하는 패턴
	- 싱글톤 방식의 주의점
		- 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 **무상태(stateless)로 설계해야 한다.**
	- @Configuration과 싱글톤
		- 스프링 컨테이너는 어떻게 싱글톤을 보장할까?
			- 여러번 호출 ❌, 한 번만 호출 ⭕️
			- `@Configuration`[[싱글톤 컨테이너#^CGLIB]]
				- 스프링이 **CGLIB**라는 **바이트코드 조작 라이브러리를 사용**
				- **임의의 다른 클래스를 만들고 이를 스프링 빈으로 등록**
				- **이 임의의 다른 클래스가 싱글톤이 보장**
		- @Configuration을 적용하지 않고 **@Bean만 적용한다면?**
			- @Bean만 사용해도 스프링 빈으로 등록되지만, **싱글톤을 보장하지 않는다.**
			- CGLIB 기술 없이 **순수한** AppConfig로 스프링 빈에 등록
			- **각각 다른 인스턴스를 생성**
	- [[의존관계 자동 주입]]
		- 컴포넌트 스캔
			- `@ComponentScan`은 `@Component`가 붙은 **모든 클래스를 스프링 빈으로 등록**한다.
				- 설정 정보에 @Bean을 매번 입력해줄 필요가 없다.
			- 생성자에 `@Autowired`를 지정하면, 스프링 컨테이너가 **자동으로 해당 스프링 빈을 찾아서 주입**한다.
				- **생성자에 파라미터가 많아도 다 찾아서 자동으로 주입**한다.
			- **기본 조회 전략**은 **타입이 같은 빈을 찾아서 주입**한다.
		- 생성자 주입을 선택해라 !
			- 불변
				- 대부분의 의존관계는 애플리케이션 종료 전까지 변경하면 안된다.
				- 수정자 주입 -> 변경 가능성 존재(public method) -> 잘못된 설계
			- 누락
				- **생성자 주입을 사용하면** 주입 데이터를 **누락했을 때** **컴파일 오류가 발생**한다.
				- 생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있다.
					- 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.
		- 롬복과 최신 트랜드: `@RequiredArgsConstructor`
		- 조회 빈이 2개 이상 시 발생했을 때 해결 방법
			- @Autowired 필드명 매칭
			- @Qualifier -> @Qualifier끼리 매칭 -> 빈 이름 매칭
				![[Pasted image 20241118195125.png]]![[Pasted image 20241118195213.png]]
			- @Primary 사용
				- @Primary 는 우선순위를 정하는 방법이다.
					![[Pasted image 20241118195403.png]]
					
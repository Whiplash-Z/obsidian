# 컴포넌트 스캔과 의존관계 자동 주입
- 지금까지 스프링 빈을 등록할 때 자바 코드의 `@Bean`을 통해서
	설정 정보에 **직접 등록할 스프링 빈을 나열**했다.
	- 이렇게 등록할 빈이 많아진다면
		- 설정 정보도 커지고,
		- 누락하는 문제
		- 매번 반복적으로 `@Bean`을 등록해야 하는 귀찮음이 생긴다.
- 그래서 스프링은 **설정 정보가 없어도 자동으로 스프링 빈을 등록**하는
  **컴포넌트 스캔**이라는 기능을 제공한다.
- **의존관계를 자동으로 주입**하는 **@Autowired**라는 기능도 제공한다.

```java
package hello.core;  
  
import org.springframework.context.annotation.ComponentScan;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.context.annotation.FilterType;  
  
@Configuration  
@ComponentScan(  
        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class)  
)  
public class AutoAppConfig {  
}
```
- 컴포넌트 스캔을 사용하려면 `@ComponentScan`을 설정 정보에 붙여주면 된다.
- 기존의 AppConfig와는 다르게 **@Bean으로 등록한 클래스가 하나도 없다.**
- `@ComponentScan` 이름 그대로 `@Component` 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.

>[!Warning] 참고: excludeFilters를 사용한 이유
>컴포넌트 스캔을 사용하면 **@Configuration이 붙은 설정 정보도 자동으로 등록**되기 때문에, AppConfig, TestConfig등 앞서 만들어두었던 설정 정보도 함께 등록되어 실행된다.
>따라서 `excludeFilters`를 이용해서 **기존 설정 정보는 컴포넌트 스캔 대상에서 제외**했다.
>
>@Configuration이 컴포넌트 스캔의 대상이된 이유도 @Configuration 소스코드를 열어보면, @Component 애노테이션이 붙어있기 때문이다.


## 컴포넌트 스캔 동작 방식
![[Pasted image 20241118145337.png]]
1. `@ComponentScan`은 `@Component`가 붙은 **모든 클래스를 스프링 빈으로 등록**한다.
2. 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자로 사용한다.

![[Pasted image 20241118145455.png]]
![[Pasted image 20241118145608.png]]
1. 생성자에 `@Autowired`를 지정하면, 스프링 컨테이너가 **자동으로 해당 스프링 빈을 찾아서 주입**
2. **기본 조회 전략**은 **타입이 같은 빈을 찾아서 주입**한다.
   getBean(MemberRepository.class)와 동일하다.
3. **생성자에 파라미터가 많아도 다 찾아서 자동으로 주입**한다.

```java
@Component
public class MemoryMemberRepository implements MemberRepository {}
```
```java
@Component
public class RateDiscountPolicy implements DiscountPolicy {}
```
```java
@Component  
public class MemberServiceImpl implements MemberService {  
  
    // 역할(인터페이스)에만 의존  
    private final MemberRepository memberRepository;  
  
    // 생성자 추가  
    @Autowired  
    public MemberServiceImpl(MemberRepository memberRepository) {  
        this.memberRepository = memberRepository;  
    }
}
```
- @Component 추가
	- `MemoryMemberRepository`, `RateDiscountPolicy`
- @Component, @Autowired 추가
	- `MemberServiceImpl`
- AppConfig에서는 `@Bean`으로 **직접 설정 정보를 작성**하고, **의존관계도 직접 명시**했다.
	- 이제는 이런 설정 정보 자체가 없기 때문에, 의존관계 주입도 이 클래스 안에서 해결해야 한다.
	- `@Autowired`는 의존관계를 자동으로 주입해준다.
	- `@Autowired`를 사용하면 생성자에서 여러 의존관계도 한번에 주입받을 수 있다.
```java
@Component  
public class OrderServiceImpl implements OrderService {  
  
    // 역할(인터페이스)에만 의존  
    private final MemberRepository memberRepository;  
    private final DiscountPolicy discountPolicy;  
  
    // 생성자 추가  
    @Autowired  //여러 의존관계 한번에 주입
    public OrderServiceImpl(  
            MemberRepository memberRepository,  
            DiscountPolicy discountPolicy  
    ) {  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }
}
```
```java
public class AutoAppConfigTest {  
  
    @Test  
    void basicScan() {  
        ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class);  
        MemberService memberService = ac.getBean(MemberService.class);  
        
        Assertions.assertThat(memberService).isInstanceOf(MemberService.class);  
    }  
}
```
```
ClassPathBeanDefinitionScanner - Identified candidate component class: 
.. RateDiscountPolicy.class
.. MemberServiceImpl.class 
.. MemoryMemberRepository.class
.. OrderServiceImpl.class
```


# 다양한 의존관계 주입 방법


# 옵션 처리


# 생성자 주입을 선택해라 !


# 롬복과 최신 트랜드


# 조회 빈이 2개 이상 - 문제

# @Autowired 필드 명, @Qualifier, @Primary


# 애노테이션 직접 만들기


# 조회한 빈이 모두 필요할 때, List, Map



# 자동, 수동의 올바른 실무 운영 기준
- [[a) 인터넷 네트워크]]
	- 인터넷에서 컴퓨터끼리 어떻게 통신을 할까?
		- 복잡한 인터넷망을 통해 데이터를 주고 받기 위해서 IP가 필요하다.
		- IP(인터넷 프로토콜)
			- IP 주소 부여
			- 지정한 IP(IP Address)에 데이터 전달
			- **패킷(Packet)** 이라는 통신 단위로 데이터 전달
				- IP 패킷 규칙: 나의 IP(출발지)와 목적지 IP를 적어야 한다.
			- IP 패킷 정보 생성 -> 클라이언트 패킷 전달(요청) -> 서버 패킷 전달(응답)
		- IP 프로토콜의 한계
			- 비연결성: 받을 대상이 없거나, **서비스 불능 상태여도 패킷 전송**
			- 비신뢰성: 패킷 손실, 전달 **순서를 보장하지 않음**
			- 프로그램 구분: 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면 **구분할 수 없음.**
		- **TCP(Transmission Control Protocol)**: 전송 제어 프로토콜
			- TCP 프로토콜이 **IP 프로토콜의 한계를 해결**한다.
			- 연결지향 - TCP 3 way handshake
			- 데이터 전달 보증
			- 순서 보장
		- UDP
			- <연결 지향, 데이터 전달 보증, 순서보장>이 되지 않는다.
			- 하지만 **단순하고 빠르다.**
			- IP와 거의 같지만, PORT와 체크섬 정도의 기능이 추가됨
			- 애플리케이션에서 추가 작업이 필요하다. (기능 확장 가능)
		- PORT
			- 같은 IP 내에서 **프로세스를 구분**하는 것.
			- IP 내에서 동작하는 애플리케이션을 구분해서 통신하기 위해 사용
		- DNS
			- IP는 변하기 쉽고, 외우기 어렵다.
			- 도메인 명을 IP 주소로 변환
			- 도메인명을 등록해서 사용할 수 있도록 도와준다.
- [[b) URI와 웹 브라우저 요청 흐름]]
	- URI(Uniform Resource Identifier): 리소스를 식별하는 통합된 방법
		- URL: Resource Locator = 리소스의 위치 (강준호의 위치)
		- URN: Resource Name = 리소스의 이름 (강준호)
	- https://www.google.com/search?q=hello&hl=ko
		- 프로토콜: https
			- 어떤 방식으로 자원에 접근할 것인가?
			- **클라이언트와 서버간의 약속과 규칙**
			- ex) http, https, ftp 등등
		- 호스트명: www.google.com 
			- 도메인명 또는 IP 주소를 직접 사용가능
		- 포트번호: 443 (생략 가능)
		- 패스(path): /search
			- 리소스 경로, **계층적 구조**
			- ex) /members, /members/100, /items/iphone12
		- 쿼리 파라미터: q=hello&hl=ko
			- key=value 형태
			- ?로 시작, &로 추가 가능
			- ex) ?keyA=valueA&keyB=valueB
	- 웹 브라우저 요청 흐름
		1. 검색: https://www.google.com/search?q=hello&hl=ko
			분석: https://200.200.200.2:443/search?q=hello&hl=ko
			- DNS 조회 -> IP 확인
			- PORT 확인
		2. 애플리케이션 계층
			- 웹 브라우저가 HTTP 요청 메시지 생성
			- SOCKET 라이브러리를 통해 OS에 전달
			- TCP/IP 연결(IP, PORT): 3-way hand shake
			- 데이터를 OS(네트워크 계층)에 전달
		3. OS(네트워크) 계층
			- HTTP 메시지가 포함된 TCP/IP 패킷 생성
		4. 네트워크 인터페이스 계층
			- 목적지 서버에 전달
- [[c) HTTP 기본]]
	- 클라이언트 서버 구조
		- Request <-> Response 구조
		- 클라이언트는 서버에 요청을 보내고 응답을 대기한다.
		- 서버가 요청에 대한 결과를 만들어서 응답한다.
		- 클라이언트는 UI/UX에 집중하고, 서버는 복잡한 비즈니스 로직에만 집중할 수 있다
	- 무상태 프로토콜 (Stateless)
		- 서버가 클라이언트의 상태를 보존하지 않는다.
			- 장점: 서버 확장성이 높음(스케일 아웃)
				- 클라이언트가 필요한 정보를 모두 담아서 주기 때문에 아무 서버나 호출해도 된다.
				- 중간에 서버에 장애가 발생했을 때 다른 서버에 요청해도 문제 없다.
			- 단점: 클라이언트가 추가 데이터 전송
				- 중간에 서버 장애가 발생하면 다른 서버에서는 클라이언트가 무엇을 목적으로 요청했는지 모른다.
	- 비 연결성(connectionless)
		- 요청을 하고 응답을 받으면 연결을 유지하지 않고 종료해서 최소한의 자원만 사용
		- HTTP는 기본적으로 비 연결성 모델이다.
		- 한계
			- TCP/IP 연결을 새로 맺어야 한다.
				- 연결마다 3-way handshake 시간이 추가된다.
			- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, CSS, 이미지 등 수많은 자원이 함께 다운로드 된다.
		- 극복
			- 지금은 HTTP 지속 연결(Persistent Connections)로 문제를 해결했다.
	- HTTP 메시지
		- ![[Pasted image 20241120011642.png]]
- [[d) HTTP 메서드]]
	- HTTP 메서드: 클라이언트가 서버에 요청을 할 때 기대하는 행동
		- GET: 리소스 조회
			- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
			- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음.
		- POST: 요청 데이터 처리, 주로 등록에 사용
			- **메시지 바디를 통해서 서버로 요청 데이터 전달**
			- 서버는 요청 데이터를 처리
				- **메시지 바디를 통해 들어온 데이터를 처리**하는 모든 기능을 수행한다.
				- 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 **프로세스를 처리해야 하는 경우도 포함** ex) 결제완료 -> 배달시작 -> 배달완료
		- PUT:리소스를 **대체**, 해당 리소스가 없으면 생성
			- 리소스가 이미 있을 경우, 요청한 정보로 덮어쓴다.
			- 클라이언트가 리소스 위치를 알고 URI를 지정해서 요청한다.
		- PATCH: 리소스 부분 변경
		- DELETE: 리소스 삭제
	- HTTP 메서드의 속성
		- 안전(Safe)
			- 호출해도 리소스를 변경하지 않는다.
			- 안전은 리소스만 고려한다. (장애 발생여부 고려 ❌)
		- **멱등(Idenmpotent)**
			- 한 번 호출하든 두 번 호출하든 100번 호출하든 **결과가 똑같다.**
			- 멱등 메서드
				- GET: 100번을 조회해도 같은 결과가 조회된다.
				- PUT: 결과를 대체한다. 같은 요청을 해도 최종 결과는 같다.
				- DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
				- **POST**: **멱등이 아니다.** 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.
			- 활용
				- 자동 복구 매커니즘
					DELETE를 호출했는데 서버에서 응답이 없을 경우
					클라이언트가 재시도 요청 -> 이렇게 해도 멱등하기 때문에 문제가 없다.
			- Q. 재요청 중간에 다른 곳에서 리소스를 변경해버리면?
			  멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.
		- 캐시가능(Cacheable)
			- 응답 결과 리소스를 캐시해서 사용해도 되는가?
			- GET, HEAD, POST, PATCH 캐시가능
				- 실제로는 GET, HEAD 정도만 캐시로 사용
				- POST,PATCH는 본문 내용까지 캐시 키로 고려해야 하는데,구현이 쉽지않음
- [[e) HTTP 메서드 활용]]
	- 클라이언트에서 서버로 데이터 전송
	- HTTP API 설계 예시


>[!Info] 필터는 서블릿이 제공하는 기능, 인터셉터는 스프링이 제공하는 기능


>[!Info] 웹과 관련된 공통 관심사는 서블릿 필터 또는 스프링 인터셉터를 사용하는 것이 좋다.
>공통 관심사는 스프링의 AOP로도 해결이 가능하지만, 웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL의 정보들이 필요한데, 서블릿 필터나 스프링 인터셉터는 'HttpServletRequest'를 제공한다.



# 서블릿 필터
>[!Info] 필터는 서블릿이 지원하는 수문장이다.

> 필터 흐름
> HTTP 요청 -> WAS(서버) -> **필터** -> 서블릿(Dispatcher Servlet) -> 컨트롤러


> 필터 제한
- HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 (로그인 사용자)
- HTTP 요청 -> WAS -> 필터(**적절하지 않은 요청으로 판단: 서블릿 호출 X**) (비로그인 사용자)
	- 필터에서 적절하지 않은 요청이라고 판단하면 거기에서 끝을 낼 수도 있다.
	- 로그인 여부를 체크하기에 딱 좋다 !

> 필터 체인

- HTTP 요청 -> WAS -> **필터 1 -> 필터 2 -> 필터 3** -> 서블릿 -> 컨트롤러
	- 필터는 체인으로 구성되는데, 중간에 필터를 자유롭게 추가할 수 있다.
	- 예를 들어서, 로그를 남기는 필터를 먼저 적용하고,
	  그 다음에 로그인 여부를 체크하는 필터를 만들 수 있다.

> 필터 인터페이스

```java
public interface Filter {
	@Override  
	public void init(FilterConfig filterConfig) throws ServletException {  
	    Filter.super.init(filterConfig);  
	}  
	  
	@Override  
	public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {  
	    }  
	  
	@Override  
	public void destroy() {  
	    Filter.super.destroy();  
	}
}
```

- 필터 인터페이스를 구현하고 등록하면 서블릿 컨테이너가 필터를 싱글톤 객체를 생성하고 관리한다.
- `init()`: 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다.
- `doFilter()`: 고객의 요청이 올 때마다 해당 메서드가 호출된다.
	- 필터의 로직을 구현하면 된다.
- `destroy()`: 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다.


# 스프링 인터셉터


# ArgumentResolver 활용


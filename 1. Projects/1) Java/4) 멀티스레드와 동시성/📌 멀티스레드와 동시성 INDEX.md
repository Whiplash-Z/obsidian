- [[프로세스와 스레드]]
	- 프로그램의 실행
		- 프로그램을 구성하는 코드를 순서대로 CPU에서 연산(실행)하는 일
	- 멀티태스킹(Multitasking)
		- **단일 CPU(단일 CPU Core)** 가 여러 작업을 **동시에 수행하는 것처럼** 보이게 하는 것. (이를 위해 운영체제는 스케줄링 기법을 사용)
	- 멀티프로세싱(Multiprocessing)
		- **여러 CPU(여러 CPU Core)를 사용**하여 동시에 여러 작업을 수행하는 것.
	- 프로세스(Process): 운영체제 안에서 실행중인 프로그램
		- **실행 환경과 자원을 제공**하는 컨테이너 역할
		- (프로그램 -> 실행 명령 -> 프로세스 생성 -> 프로그램 실행)
		- **독립적인 메모리 공간**을 가지고 있고, 운영체제에서 **별도의 작업 단위로 분리해서 관리**하기 때문에 하나의 **프로세스가 충돌해도 다른 프로세스에는 영향을 미치지 않는다.**
	- 스레드(Thread): 프로세스 내에서 실행되는 작업 단위(실제로 CPU에 의해 실행)
		- CPU를 사용해서 **코드를 하나하나 실행**하는 역할
		- **하나의 프로세스 안에는 최소 하나의 스레드가 존재**해야 프로그램이 실행될 수 있다.
		- 한 프로세스 내에서 여러 스레드가 존재할 수 있다. (멀티스레드)
		- 메모리 구성
			- 공유 메모리: 같은 프로세스의 코드 섹션, 데이터 섹션, 힙(메모리)은 **프로세스 안의 모든 스레드가 공유한다.**
			- 개별 스택: 각 스레드는 **자신의 스택을 갖고 있다.**
	- 스케줄링: CPU에 어떤 프로그램이 얼마만큼 실행될지 운영체제에서 결정한다. 
		- 운영체제는 내부에 **스케줄링 큐**를 가지고 있고, 각각의 **스레드는 스케줄링 큐에서 대기한다.**
		- 단순히 시간만으로 작업을 분할하지는 않고, CPU를 최댛란 활용할 수 있는 다양한 운선순위와 최적화 기법을 사용한다.
- 스레드의 생성과 실행
	- 스레드 간 **실행 순서는 보장하지 않는다.**
	- 스레드 생성 - Thread 상속
		- Thread 클래스를 상속하고, 스레드가 실행할 코드를 run() 메서드에 재정의
		- 스레드 객체를 생성하고 `start()` 메서드 호출
		- `start()` 메서드를 호출하면 생성된 스레드가 `run()` 메서드를 실행한다.
		- start() 메서드를 호출해야 **스택 공간을 할당** 받고 스레드가 작동한다.
	- start() VS run()
		- run() 메서드를 직접 호출하면, 별도의 스레드(Thread-0)가 run()을 실행하는 것이 아니라, main 스레드가 run()메서드를 실행한다.
		- 별도의 스레드에서 재정의한 run() 메서드를 실행하려면 반드시 start() 메서드를 호출해야 한다.
	- 데몬 스레드
		- 스레드는 **사용자(user)스레드** & **데몬(daemon)스레드** 2가지 종류로 구분한다.
		- 사용자 스레드
			- 프로그램의 주요 작업 수행
			- 작업이 완료될 때까지 수행
			- **모든 user 스레드가 종료되면 JVM도 종료**
		- 데몬 스레드
			- 백그라운드에서 보조적인 작업을 수행
			- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료
		- **JVM은 데몬 스레드의 실행 완료를 기다리지 않고 종료된다.**
	- 스레드 생성 - Runnable
		- 스레드와 해당 스레드가 실행할 작업이 서로 분리되어있다.
		- 스레드 객체를 생성할 때, 실행할 작업을 생성자로 전달하면 된다.
		- 장점
			- 여러 스레드가 동일한 Runnable 객체를 공유할 수 있어서 자원 관리를 효율적으로 할 수 있다.
			- 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
			- 다른 클래스를 상속 받아도 문제없이 구현할 수 있다.
		- Runnable 인터페이스를 구현하는 방식을 사용하자!
- [[스레드 제어와 생명 주기]]
  ![[Pasted image 20241203132756.png]]
	- 자바 스레드의 상태 전이 과정
		- **NEW -> Runnable**
		  `start()` 메서드를 호출하면 스레드가 Runnable 상태로 전이됨.
		- **Runnable -> Blocked/Waiting/Timed Waiting**
		  스레드가 락을 얻지 못하거나, `wait()` 또는 `sleep()` 메서드를 호출할 때
		  해당 상태로 전이된다.
		- **Blocked/Waiting/Timed Waiting -> Runnable**
		  스레드가 락을 얻거나, 기다림이 완료되면 다시 Runnable 상태로 돌아간다.
		- **Runnable -> Terminated**
		  스레드의 `run()` 메서드가 종료되면 스레드는 Terminated 상태가 된다.
	- NEW (새로운 상태): 스레드가 **생성**되었으나 **아직 시작되지 않은** 상태
	- Runnable (실행 가능 상태): 스레드가 **실행 중**이거나 **실행될 준비**가 된 상태
	- 일시 중지 상태들(Suspended States) -> CPU의 실행 스케줄러에 들어가지 않는다.
		- Blocked (차단 상태): 스레드가 **동기화 락**을 기다리는 상태
		- Waiting (대기 상태): 스레드가 **무기한**으로 다른 스레드의 작업을 기다리는 상태
		- Timed Waiting(시간 제한 대기 상태)
		  스레드가 **일정 시간 동안** 다른 스레드의 작업을 기다리는 상태
		- Terminated (종료 상태): 스레드의 **실행이 완료**된 상태
	- join(), join(ms)
		- 스레드는 호출한 스레드가 **끝날 때 까지 기다리지 않는다.**
		- 호출한 스레드가 종료된 다음에 작업을 진행하려면?
		- Waiting (대기 상태) - join()
			- 스레드가 다른 스레드의 특정 작업이 완료되기를 **무기한 기다리는 상태**이다.
			- `join()`을 호출하는 스레드는 **대상 스레드가 TERMINATED 상태가 될때까지 대기**한다.
			- 대상 스레드가 `TERMINATED` 상태가 되면 **호출 스레드는 다시 RUNNABLE 상태**가 되면서 다음 코드를 수행한다.
			- RUNNABLE -> join() -> WAITING -> 대상 스레드 작업 완료(TREMINATED)
				-> RUNNABLE -> 다음 로직 수행(없다면 종료)
		- TIMED_WAITING - join(ms)
			- 호출 스레드는 **특정 시간 만큼만 대기**한다.
			- 호출 스레드는 지정한 시간이 지나면 다시 `RUNNABLE` 상태가 되면서
			  다음 코드를 수행
	- 인터럽트(Interrupt)
		- 

- [[프로세스와 스레드]]
	- 프로그램의 실행
		- 프로그램을 구성하는 코드를 순서대로 CPU에서 연산(실행)하는 일
	- 멀티태스킹(Multitasking)
		- **단일 CPU(단일 CPU Core)** 가 여러 작업을 **동시에 수행하는 것처럼** 보이게 하는 것. (이를 위해 운영체제는 스케줄링 기법을 사용)
	- 멀티프로세싱(Multiprocessing)
		- **여러 CPU(여러 CPU Core)를 사용**하여 동시에 여러 작업을 수행하는 것.
	- 프로세스(Process): 운영체제 안에서 실행중인 프로그램
		- **실행 환경과 자원을 제공**하는 컨테이너 역할
		- (프로그램 -> 실행 명령 -> 프로세스 생성 -> 프로그램 실행)
		- **독립적인 메모리 공간**을 가지고 있고, 운영체제에서 **별도의 작업 단위로 분리해서 관리**하기 때문에 하나의 **프로세스가 충돌해도 다른 프로세스에는 영향을 미치지 않는다.**
	- 스레드(Thread): 프로세스 내에서 실행되는 작업 단위(실제로 CPU에 의해 실행)
		- CPU를 사용해서 **코드를 하나하나 실행**하는 역할
		- **하나의 프로세스 안에는 최소 하나의 스레드가 존재**해야 프로그램이 실행될 수 있다.
		- 한 프로세스 내에서 여러 스레드가 존재할 수 있다. (멀티스레드)
		- 메모리 구성
			- 공유 메모리: 같은 프로세스의 코드 섹션, 데이터 섹션, 힙(메모리)은 **프로세스 안의 모든 스레드가 공유한다.**
			- 개별 스택: 각 스레드는 **자신의 스택을 갖고 있다.**
	- 스케줄링: CPU에 어떤 프로그램이 얼마만큼 실행될지 운영체제에서 결정한다. 
		- 운영체제는 내부에 **스케줄링 큐**를 가지고 있고, 각각의 **스레드는 스케줄링 큐에서 대기한다.**
		- 단순히 시간만으로 작업을 분할하지는 않고, CPU를 최댛란 활용할 수 있는 다양한 운선순위와 최적화 기법을 사용한다.
- 스레드의 생성과 실행
	- 스레드 간 **실행 순서는 보장하지 않는다.**
	- 스레드 생성 - Thread 상속
		- Thread 클래스를 상속하고, 스레드가 실행할 코드를 run() 메서드에 재정의
		- 스레드 객체를 생성하고 `start()` 메서드 호출
		- `start()` 메서드를 호출하면 생성된 스레드가 `run()` 메서드를 실행한다.
		- start() 메서드를 호출해야 **스택 공간을 할당** 받고 스레드가 작동한다.
	- start() VS run()
		- run() 메서드를 직접 호출하면, 별도의 스레드(Thread-0)가 run()을 실행하는 것이 아니라, **main 스레드가 run()메서드를 실행한다.**
		- 별도의 스레드에서 재정의한 run() 메서드를 실행하려면 **반드시 start() 메서드를 호출해야 한다.**
	- 데몬 스레드
		- 스레드는 **사용자(user)스레드** & **데몬(daemon)스레드** 2가지 종류로 구분한다.
		- 사용자 스레드
			- 프로그램의 주요 작업 수행
			- 작업이 완료될 때까지 수행
			- **모든 user 스레드가 종료되면 JVM도 종료**
		- 데몬 스레드
			- 백그라운드에서 보조적인 작업을 수행
			- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료
		- **JVM은 데몬 스레드의 실행 완료를 기다리지 않고 종료된다.**
	- 스레드 생성 - **Runnable**
		- 스레드와 해당 스레드가 실행할 작업이 서로 분리되어있다.
		- 스레드 객체를 생성할 때, 실행할 작업을 생성자로 전달하면 된다.
		- 장점
			- 여러 스레드가 동일한 Runnable 객체를 공유할 수 있어서 자원 관리를 효율적으로 할 수 있다.
			- 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
			- 다른 클래스를 상속 받아도 문제없이 구현할 수 있다.
		- Runnable 인터페이스를 구현하는 방식을 사용하자!
- [[스레드 제어와 생명 주기]]
  ![[Pasted image 20241203132756.png]]
	- 자바 스레드의 상태 전이 과정
		- **NEW -> Runnable**
		  `start()` 메서드를 호출하면 스레드가 Runnable 상태로 전이됨.
		- **Runnable -> Blocked/Waiting/Timed Waiting**
		  스레드가 락을 얻지 못하거나, `wait()` 또는 `sleep()` 메서드를 호출할 때
		  해당 상태로 전이된다.
		- **Blocked/Waiting/Timed Waiting -> Runnable**
		  스레드가 락을 얻거나, 기다림이 완료되면 다시 Runnable 상태로 돌아간다.
		- **Runnable -> Terminated**
		  스레드의 `run()` 메서드가 종료되면 스레드는 Terminated 상태가 된다.
	- NEW (새로운 상태): 스레드가 **생성**되었으나 **아직 시작되지 않은** 상태
	- Runnable (실행 가능 상태): 스레드가 **실행 중**이거나 **실행될 준비**가 된 상태
	- 일시 중지 상태들(Suspended States) -> CPU의 실행 스케줄러에 들어가지 않는다.
		- Blocked (차단 상태): 스레드가 **동기화 락**을 기다리는 상태
		- Waiting (대기 상태): 스레드가 **무기한**으로 다른 스레드의 작업을 기다리는 상태
		- Timed Waiting(시간 제한 대기 상태)
		  스레드가 **일정 시간 동안** 다른 스레드의 작업을 기다리는 상태
		- Terminated (종료 상태): 스레드의 **실행이 완료**된 상태
	- join(), join(ms)
		- 스레드는 호출한 스레드가 **끝날 때 까지 기다리지 않는다.**
		- 호출한 스레드가 종료된 다음에 작업을 진행하려면?
		- Waiting (대기 상태) - join()
			- 스레드가 다른 스레드의 특정 작업이 완료되기를 **무기한 기다리는 상태**이다.
			- `join()`을 호출하는 스레드는 **대상 스레드가 TERMINATED 상태가 될때까지 대기**한다.
			- 대상 스레드가 `TERMINATED` 상태가 되면 **호출 스레드는 다시 RUNNABLE 상태**가 되면서 다음 코드를 수행한다.
			- RUNNABLE -> join() -> WAITING -> 대상 스레드 작업 완료(TREMINATED)
				-> RUNNABLE -> 다음 로직 수행(없다면 종료)
		- TIMED_WAITING - join(ms)
			- 호출 스레드는 **특정 시간 만큼만 대기**한다.
			- 호출 스레드는 지정한 시간이 지나면 다시 `RUNNABLE` 상태가 되면서
			  다음 코드를 수행
	- Interrupt
		- 인터럽트를 사용하면 WAITING, TIMED_WAITING 같은 대기 상태의 스레드를 직접 깨워서, 작동하는 RUNNABLE 상태로 만들 수 있다.
		- interrupt() 메서드를 호출했다고 해서 즉각 InterruptedException이 발생하는 것은 아니다.
		- 오직 sleep() 처럼 InterruptedException을 던지는 메서드를 호출하거나 호출 중일 때 예외가 발생한다.
- volatile - 메모리 가시성
	- 메모리 가시성(memory visibility)
		- 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제
	- 일반적으로는 스레드가 데이터를 메인 메모리에 접근해서 확인하는 것으로 생각하지만,
	  실제로는 CPU가 처리 성능을 개선하기 위해 중간에 **캐시 메모리를 사용한다.**
	- 따라서, 한 스레드에서 값을 변경해도 **캐시 메모리의 값만 변경**되고,
	  **메인 메모리에 값이 즉시 반영되지 않는다.** (컨텍스트 스위칭 시 반영)
	- 만약, **여러 스레드에서 같은 시점에 같은 데이터를 보는 것이 더 중요한 상황**이라면
	  `volatile` 키워드를 사용해서 **메인 메모리에 직접 접근하여 데이터 변경을 확인**한다.
- 동기화 - sysnchronized: **한번에 하나의 스레드만 실행**하는 안전한 **임계 영역 생성**
	- 멀티스레드 환경에서 필드(멤버 변수)는 여러 스레드가 함께 사용하는 **공유자원**이다.
	- 따라서 로직을 수행하는 **중간에 다른 스레드에서 얼마든지 값을 변경**할 수 있다.
	- synchronized를 사용하면 로직을 처리할 때 한 번에 하나의 스레드만 실행하도록 한다.
		- 하나의 스레드가 전체 로직을 수행하고 나서 다른 스레드가 수행한다.
		- **모든 객체(인스턴스)는 내부에 자신만의 락**(monitor lock)을 가지고 있다.
		- 스레드가 syncrhonized 키워드가 있는 메서드에 진입하려면 **반드시 해당 인스턴스의 락이 있어야 한다.**
		- 호출한 스레드 락 획득 -> 나머지 호출 스레드는 **락을 획득할 때까지** RUNNABLE -> **BLOCKED 상태로 무한정 대기** (CPU 실행 스케줄링에 들어가지 않는다.)
		- 호출한 스레드의 **호출이 끝나면 락을 반납** -> 락 획득을 **대기중인 스레드가 락 획득** (BLOCKED -> RUNNABLE) -> 코드 실행 (반복)
			- **락을 획득하는 순서는 보장되지 않는다.**
			- **환경에 따라서 순서가 달라질 수 있다.**
	- **지역 변수는 절대로! 다른 스레드와 공유되지 않는다.**
	- 스택 영역은 각각의 스레드가 가지는 별도의 메모리 공간이다.
		- 이 메모리 공간은 다른 스레드와 공유하지 않는다.
		- 지역 변수는 스레드의 개별 저장 공간인 스택 영역에 생성된다.
	- final 필드
		- 진짜 문제는 **공유 자원을 사용하는 중간에 다른 스레드가 공유 자원의 값을 변경해버리기 때문에 발생한다.**
		- 결국 변경이 문제가 되는 것이다.
		- 여러 스레드가 접근 가능한 공유 자원이라도 **그 값을 아무도 변경할 수 없다면 문제 되지 않는다.** 
		- 필드에 final이 붙으면 어떤 스레드도 값을 변경할 수 없기 때문에 멀티스레드 상황에 문제 없는 안전한 공유 자원이 된다.
	- sysnchronized 장점
		- 프로그래밍 언어에 문법으로 제공
		- 아주 편리한 사용
		- **자동 잠금 해제**
			- syncrhonized 메서드나 블록이 완료되면 자동으로 락을 대기중인 다른 스레드의 잠금이 해제된다.
	- sysnchronized 단점
		- 무한 대기
			- BLOCKED 상태의 스레드는 **락이 풀릴 때까지 무한 대기**한다.
			- 특정 시간까지만 대기 후 타임아웃이 되어도 상태가 변경되지 않는다.
			- 중간에 인터럽트도 불가능하다.
		- 공정성
			- 락이 돌아왔을 때, BLOCKED 상태의 **여러 스레드 중에 어떤 스레드가 락을 획득할지 알 수 없다.**
			- 최악의 경우 특정 스레드가 너무 오랜기간 락을 획득하지 못할 수 있다.
- concurrent.Lock
	- `synchronized`의 단점을 해결하기 위해 `java.util.concurrent` 동시성 문제 해결 패키지 추가
	- LockSupport: 스레드를 WAITING, TIMED_WAITING 상태로 변경 가능, 인터럽트에 반응함.
		- 스레드를 WAITING 상태로 변경한다.
			- WAITING 상태는 누군가 깨워주기 전까지는 계속 대기한다.
			- CPU 실행 스케줄링에 들어가지 않는다.
		- 기능
			- park(): 스레드를 `WAITING` 상태로 변경
				- 스레드를 대기 상태로 둔다. (RUNNABLE -> WAITING)
			- parkNanos(nanos):: 스레드를 나노초 동안만 `TIMED_WAITING` 상태로 변경
				- 지정한 나노초가 지나면 `TIMED_WAITING` 상태에서 `RUNNABLE` 상태로 변경
			- unpark(thread): `WAITING` 상태의 대상 스레드를 `RUNNABLE` 상태로 변경
		- Interrupt를 발생시키면 WAITING -> RUNNABLE 상태로 변경된다.
			- BLOCKED 상태는 인터럽트가 걸려도 대기 상태에서 빠져나오지 못한다.
				- synchronized에서 락을 획득하기 위해 대기할 때 사용된다.
			- WAITING, TIMED_WAITING 상태는 인터럽트가 걸리면 대기 상태를 빠져나온다.
				- WAITING, TIMED_WAITING -> Interrupt -> RUNNABLE
				- Thread.join(), LockSupprot.park(), Object.wait()와 같은 메서드 호출 시 WAITING 상태가 된다.
				- Thread.sleep(ms), Object.wait(long timeout), Thread.join(long millis), LockSupport.parkNanos(ns) 등과 같은 시간 제한이 있는 대기 메서드를 호출할 때 TIMED_WAITING 상태가 된다.
	- ReentrantLock
		- synchronized와 BLOCKED 상태를 통한 임계 영역 관리의 한계를 극복하기 위해 자바 1.5부터 Lock 인터페이스와 ReentrantLock 구현체를 제공한다.
		- synchronized의 무한대기 문제 해결  
		    - `void lock()`
			    - **락을 획득**한다.
			    - 만약 다른 스레드가 이미 락을 획득했다면, **락이 풀릴 때까지 현재 스레드는 대기**(WAITING)한다. **이 메서드는 인터럽트에 응답하지 않는다.**
			- `void lockInterruptibly()`
			    - 락 획득을 시도하되, **다른 스레드가 인터럽트 할 수 있도록 한다**.
			    - 만약 다른 스레드가 이미 락을 획득했다면, 현재 스레드는 **락을 획득할 때까지 대기**(WAITING)한다.
			    - 대기 중에 인터럽트가 발생하면 `InterruptedException`이 발생하며 락 획득을 포기한다.
			- `boolean tryLock()`
			    - 락 획득을 시도하고, **즉시 성공 여부를 반환**한다.
			    - 만약 다른 스레드가 이미 락을 획득했다면 `false`를 반환하고,  
			        그렇지 않으면 락을 획득하고 `true`를 반환한다.
			- `boolean tryLock(long time, TimeUnit unit)`
			    - **주어진 시간 동안 락 획득을 시도**한다.
			    - 주어진 시간 안에 락을 획득하면 `true`를 반환한다.
			    - 주어진 시간이 지나도 락을 획득하지 못한 경우 `false`를 반환한다.
			    - 이 메서드는 대기 중 인터럽트가 발생하면 `InterruptedException`이 발생하며, 락 획득을 포기한다.
			- `void unlock()`
			    - **락을 해제**한다.
			    - 락을 해제하면 락 획득을 **대기 중인 스레드 중 하나가 락을 획득**할 수 있게 된다.
			    - **락을 획득한 스레드가 호출**해야 하며, 그렇지 않으면 `IllegalMonitorStateException`이 발생한다.
			    - ex) 식당안에 있는 손님이 밥을 먹고 나간다. 식당에 자리가 하나 난다. 기다리는 손님께 이런 사실을 알려주어야 한다. 기다리던 손님중 한 명이 식당에 들어간다.
			- `Condition newCondition()` 
			    - `Condition` 객체를 생성하여 반환한다.
			    - `Condition` 객체는 락과 결합되어 사용되며, 스레드가 특정 조건을 기다리거나 신호를 받을 수 있도록 한다.
			    - 이는 `Object` 클래스의 `wait`, `notify`, `notifyAll` 메서드와 유사한 역할을 한다.
		- synchronized의 공정성 문제 해결
			- 비공정 모드 락: `private final Lock nonFairLock = new ReentrantLock();`
				- ReentrantLock의 기본 모드
				- 락을 먼저 요청한 스레드가 락을 먼저 획득한다는 보장이 없다.
				- 락을 풀었을 때, 대기 중인 스레드 중 아무나 락을 획득할 수 있다.
				- 락을 획득하는 속도가 빠르지만, 특정 스레드가 계속해서 락을 획득하지 못하는 기아 현상이 발생할 수 있다.
			- 공정 모드 락: `private final Lock fairLock = new ReentrantLock(true);`
				- 락을 요청한 순서대로 스레드가 락을 획득할 수 있게 된다.(공정성 보장)
				- 대기 큐에서 먼저 대기한 스레드가 락을 먼저 획득하는 것을 보장하므로 공정성을 보장하지만, 락을 획득하는 속도가 느려질 수 있다.
		- **임계 영역이 끝나면 반드시! 락을 반납해야 대기하는 스레드가 락을 얻을 수 있다.**
			- lock.unlock()은 반드시 finally 블럭에 작성해서 무조건 락을 반납해야한다.
		- 동작 원리
			- ReentrantLock 내부
				- 락과 락을 얻지 못해 대기하는 스레드를 관리하는 대기 큐가 존재.
			- t1: ReentrantLock에 있는 락을 획득
				- **락을 획득하는 경우 RUNNABLE 상태가 유지되고**, 임계 영역의 코드 실행이 가능해진다.
			- t1: 임계 영역의 코드 실행
				- t2: ReentrantLock에 있는 락의 획득을 시도하지만 락이 없다.
					- 락을 획득하지 못하면 WAITING 상태가 되고, 대기 큐에서 관리된다.
					- LockSupport.park()가 내부에서 호출된다.
			- t1: 임계 영역의 코드를 수행 완료 -> balance = 200
			- 임계 영역을 수행하고 나면 lock.unlock()을 호출
				- t1: 락을 반납하고, 대기 큐의 스레드를 하나 깨운다.
					- LockSupport.unpark(thread)가 내부에서 호출된다.
				- t2: RUNNABLE 상태가 되면서 깨어난 스레드는 락 획득을 시도한다.
					- 락을 획득하면 lock.lock()을 빠져나오면서 대기 큐에서 제거
					- 락을 획득하지 못하면 다시 대기 상태가 되고, 대기 큐에 유지
						- (스레드의 락 획득 순서를 보장하지 않는다: 비공정 락)
						- (공정 모드의 경우 대기 큐에 먼저 대기한 스레드가 먼저 락을 가져간다: 공정 락)
				- 락을 획득한 t2 스레드는 RUNNABLE 상태로 임계 영역을 수행한다.
					- 잔액(200)이 출금액(800)보다 적으므로 검증 로직을 통과하지 못하므로 return false가 호출된다.
					- finally 구문에서 lock.unlock()을 통해 락을 반납하고, 대기 큐의 스레드를 하나 깨우려고 시도한다.
					- 대기 큐에 스레드가 없으면 이때는 깨우지 않는다.
			- 

- [[프로세스와 스레드]]
	- 프로그램의 실행
		- 프로그램을 구성하는 코드를 순서대로 CPU에서 연산(실행)하는 일
	- 멀티태스킹(Multitasking)
		- **단일 CPU(단일 CPU Core)** 가 여러 작업을 **동시에 수행하는 것처럼** 보이게 하는 것. (이를 위해 운영체제는 스케줄링 기법을 사용)
	- 멀티프로세싱(Multiprocessing)
		- **여러 CPU(여러 CPU Core)를 사용**하여 동시에 여러 작업을 수행하는 것.
	- 프로세스(Process): 운영체제 안에서 실행중인 프로그램
		- **실행 환경과 자원을 제공**하는 컨테이너 역할
		- (프로그램 -> 실행 명령 -> 프로세스 생성 -> 프로그램 실행)
		- **독립적인 메모리 공간**을 가지고 있고, 운영체제에서 **별도의 작업 단위로 분리해서 관리**하기 때문에 하나의 **프로세스가 충돌해도 다른 프로세스에는 영향을 미치지 않는다.**
	- 스레드(Thread): 프로세스 내에서 실행되는 작업 단위(실제로 CPU에 의해 실행)
		- CPU를 사용해서 **코드를 하나하나 실행**하는 역할
		- **하나의 프로세스 안에는 최소 하나의 스레드가 존재**해야 프로그램이 실행될 수 있다.
		- 한 프로세스 내에서 여러 스레드가 존재할 수 있다. (멀티스레드)
		- 메모리 구성
			- 공유 메모리: 같은 프로세스의 코드 섹션, 데이터 섹션, 힙(메모리)은 **프로세스 안의 모든 스레드가 공유한다.**
			- 개별 스택: 각 스레드는 **자신의 스택을 갖고 있다.**
	- 스케줄링: CPU에 어떤 프로그램이 얼마만큼 실행될지 운영체제에서 결정한다. 
		- 운영체제는 내부에 **스케줄링 큐**를 가지고 있고, 각각의 **스레드는 스케줄링 큐에서 대기한다.**
		- 단순히 시간만으로 작업을 분할하지는 않고, CPU를 최댛란 활용할 수 있는 다양한 운선순위와 최적화 기법을 사용한다.
- 스레드의 생성과 실행
	- 스레드 간 **실행 순서는 보장하지 않는다.**
	- 스레드 생성 - Thread 상속
		- Thread 클래스를 상속하고, 스레드가 실행할 코드를 run() 메서드에 재정의
		- 스레드 객체를 생성하고 `start()` 메서드 호출
		- `start()` 메서드를 호출하면 생성된 스레드가 `run()` 메서드를 실행한다.
		- start() 메서드를 호출해야 **스택 공간을 할당** 받고 스레드가 작동한다.
	- start() VS run()
		- run() 메서드를 직접 호출하면, 별도의 스레드(Thread-0)가 run()을 실행하는 것이 아니라, **main 스레드가 run()메서드를 실행한다.**
		- 별도의 스레드에서 재정의한 run() 메서드를 실행하려면 **반드시 start() 메서드를 호출해야 한다.**
	- 데몬 스레드
		- 스레드는 **사용자(user)스레드** & **데몬(daemon)스레드** 2가지 종류로 구분한다.
		- 사용자 스레드
			- 프로그램의 주요 작업 수행
			- 작업이 완료될 때까지 수행
			- **모든 user 스레드가 종료되면 JVM도 종료**
		- 데몬 스레드
			- 백그라운드에서 보조적인 작업을 수행
			- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료
		- **JVM은 데몬 스레드의 실행 완료를 기다리지 않고 종료된다.**
	- 스레드 생성 - **Runnable**
		- 스레드와 해당 스레드가 실행할 작업이 서로 분리되어있다.
		- 스레드 객체를 생성할 때, 실행할 작업을 생성자로 전달하면 된다.
		- 장점
			- 여러 스레드가 동일한 Runnable 객체를 공유할 수 있어서 자원 관리를 효율적으로 할 수 있다.
			- 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
			- 다른 클래스를 상속 받아도 문제없이 구현할 수 있다.
		- Runnable 인터페이스를 구현하는 방식을 사용하자!
- [[스레드 제어와 생명 주기]]
  ![[Pasted image 20241203132756.png]]
	- 자바 스레드의 상태 전이 과정
		- **NEW -> Runnable**
		  `start()` 메서드를 호출하면 스레드가 Runnable 상태로 전이됨.
		- **Runnable -> Blocked/Waiting/Timed Waiting**
		  스레드가 락을 얻지 못하거나, `wait()` 또는 `sleep()` 메서드를 호출할 때
		  해당 상태로 전이된다.
		- **Blocked/Waiting/Timed Waiting -> Runnable**
		  스레드가 락을 얻거나, 기다림이 완료되면 다시 Runnable 상태로 돌아간다.
		- **Runnable -> Terminated**
		  스레드의 `run()` 메서드가 종료되면 스레드는 Terminated 상태가 된다.
	- NEW (새로운 상태): 스레드가 **생성**되었으나 **아직 시작되지 않은** 상태
	- Runnable (실행 가능 상태): 스레드가 **실행 중**이거나 **실행될 준비**가 된 상태
	- 일시 중지 상태들(Suspended States) -> CPU의 실행 스케줄러에 들어가지 않는다.
		- Blocked (차단 상태): 스레드가 **동기화 락**을 기다리는 상태
		- Waiting (대기 상태): 스레드가 **무기한**으로 다른 스레드의 작업을 기다리는 상태
		- Timed Waiting(시간 제한 대기 상태)
		  스레드가 **일정 시간 동안** 다른 스레드의 작업을 기다리는 상태
		- Terminated (종료 상태): 스레드의 **실행이 완료**된 상태
	- join(), join(ms)
		- 스레드는 호출한 스레드가 **끝날 때 까지 기다리지 않는다.**
		- 호출한 스레드가 종료된 다음에 작업을 진행하려면?
		- Waiting (대기 상태) - join()
			- 스레드가 다른 스레드의 특정 작업이 완료되기를 **무기한 기다리는 상태**이다.
			- `join()`을 호출하는 스레드는 **대상 스레드가 TERMINATED 상태가 될때까지 대기**한다.
			- 대상 스레드가 `TERMINATED` 상태가 되면 **호출 스레드는 다시 RUNNABLE 상태**가 되면서 다음 코드를 수행한다.
			- RUNNABLE -> join() -> WAITING -> 대상 스레드 작업 완료(TREMINATED)
				-> RUNNABLE -> 다음 로직 수행(없다면 종료)
		- TIMED_WAITING - join(ms)
			- 호출 스레드는 **특정 시간 만큼만 대기**한다.
			- 호출 스레드는 지정한 시간이 지나면 다시 `RUNNABLE` 상태가 되면서
			  다음 코드를 수행
	- Interrupt
		- 인터럽트를 사용하면 WAITING, TIMED_WAITING 같은 대기 상태의 스레드를 직접 깨워서, 작동하는 RUNNABLE 상태로 만들 수 있다.
		- interrupt() 메서드를 호출했다고 해서 즉각 InterruptedException이 발생하는 것은 아니다.
		- 오직 sleep() 처럼 InterruptedException을 던지는 메서드를 호출하거나 호출 중일 때 예외가 발생한다.
- volatile - 메모리 가시성
	- 메모리 가시성(memory visibility)
		- 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제
	- 일반적으로는 스레드가 데이터를 메인 메모리에 접근해서 확인하는 것으로 생각하지만,
	  실제로는 CPU가 처리 성능을 개선하기 위해 중간에 **캐시 메모리를 사용한다.**
	- 따라서, 한 스레드에서 값을 변경해도 **캐시 메모리의 값만 변경**되고,
	  **메인 메모리에 값이 즉시 반영되지 않는다.** (컨텍스트 스위칭 시 반영)
	- 만약, **여러 스레드에서 같은 시점에 같은 데이터를 보는 것이 더 중요한 상황**이라면
	  `volatile` 키워드를 사용해서 **메인 메모리에 직접 접근하여 데이터 변경을 확인**한다.
- 동기화 - sysnchronized: **한번에 하나의 스레드만 실행**하는 안전한 **임계 영역 생성**
	- 멀티스레드 환경에서 필드(멤버 변수)는 여러 스레드가 함께 사용하는 **공유자원**이다.
	- 따라서 로직을 수행하는 **중간에 다른 스레드에서 얼마든지 값을 변경**할 수 있다.
	- synchronized를 사용하면 로직을 처리할 때 한 번에 하나의 스레드만 실행하도록 한다.
		- 하나의 스레드가 전체 로직을 수행하고 나서 다른 스레드가 수행한다.
		- **모든 객체(인스턴스)는 내부에 자신만의 락**(monitor lock)을 가지고 있다.
		- 스레드가 syncrhonized 키워드가 있는 메서드에 진입하려면 **반드시 해당 인스턴스의 락이 있어야 한다.**
		- 호출한 스레드 락 획득 -> 나머지 호출 스레드는 **락을 획득할 때까지** RUNNABLE -> **BLOCKED 상태로 무한정 대기** (CPU 실행 스케줄링에 들어가지 않는다.)
		- 호출한 스레드의 **호출이 끝나면 락을 반납** -> 락 획득을 **대기중인 스레드가 락 획득** (BLOCKED -> RUNNABLE) -> 코드 실행 (반복)
			- **락을 획득하는 순서는 보장되지 않는다.**
			- **환경에 따라서 순서가 달라질 수 있다.**
	- **지역 변수는 절대로! 다른 스레드와 공유되지 않는다.**
	- 스택 영역은 각각의 스레드가 가지는 별도의 메모리 공간이다.
		- 이 메모리 공간은 다른 스레드와 공유하지 않는다.
		- 지역 변수는 스레드의 개별 저장 공간인 스택 영역에 생성된다.
	- final 필드
		- 진짜 문제는 **공유 자원을 사용하는 중간에 다른 스레드가 공유 자원의 값을 변경해버리기 때문에 발생한다.**
		- 결국 변경이 문제가 되는 것이다.
		- 여러 스레드가 접근 가능한 공유 자원이라도 **그 값을 아무도 변경할 수 없다면 문제 되지 않는다.** 
		- 필드에 final이 붙으면 어떤 스레드도 값을 변경할 수 없기 때문에 멀티스레드 상황에 문제 없는 안전한 공유 자원이 된다.
	- sysnchronized 장점
		- 프로그래밍 언어에 문법으로 제공
		- 아주 편리한 사용
		- **자동 잠금 해제**
			- syncrhonized 메서드나 블록이 완료되면 자동으로 락을 대기중인 다른 스레드의 잠금이 해제된다.
	- sysnchronized 단점
		- 무한 대기
			- BLOCKED 상태의 스레드는 **락이 풀릴 때까지 무한 대기**한다.
			- 특정 시간까지만 대기 후 타임아웃이 되어도 상태가 변경되지 않는다.
			- 중간에 인터럽트도 불가능하다.
		- 공정성
			- 락이 돌아왔을 때, BLOCKED 상태의 **여러 스레드 중에 어떤 스레드가 락을 획득할지 알 수 없다.**
			- 최악의 경우 특정 스레드가 너무 오랜기간 락을 획득하지 못할 수 있다.

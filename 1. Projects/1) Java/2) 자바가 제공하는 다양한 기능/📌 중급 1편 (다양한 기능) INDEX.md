- [[Object 클래스]]
	- 자바에서 모든 클래스의 최상위 부모는 항상 Object 클래스이다.
		- 공통 기능 제공(toString, equals, getClass ...) -> 공통 기능 사용 **일관성** ⭕️
		- 다형성의 기본 구현: 다양한 타입의 객체를 **통합적으로 처리**할 수 있게 된다.
	- Object 다형성의 장점과 단점 그리고 한계
		- 모든 객체를 대상으로 **다형적 참조를 할 수 있다.**(모든 객체를 담을 수 있다)
		- Object를 통해 전달 받은 객체를 호출하려면 각 객체에 맞는 **다운캐스팅 과정 필요**
		- 다형적 참조는 가능하지만, Object에는 dog.sound(), car.move()와 같은 메서드가 존재하지 않아서(공통 기능 제외) 메서드 오버라이딩이 안되기 때문에 **다형성을 활용하기에는 한계가 있다.**
			결국 각 객체의 기능을 호출하려면 다운캐스팅을 해야한다.
	- Object를 활용하면 좋은 상황
		- Object 배열: 모든 객체를 담을 수 있는 배열
		- toString(): 객체의 정보를 문자열 형태로 제공 (디버깅, 로깅에서 유용하게 사용)
	- Object와 OCP
		- Open: 새로운 클래스를 추가하고 toString()을 **오버라이딩해서 기능 확장 가능**
		- Closed: 새로운 클래스를 추가해도 Object와 toString()을 사용하는 클라이언트 코드인 ObjectPrinter는 **변경하지 않아도 된다.**
		- 클라이언트 코드가 구체적인 Car, Dog에 의존하는 것이 아닌,
		  추상적인 Object에 의존하기 때문에 OCP 원칙을 지킬 수 있었다.
	- equals() 동일성과 동등성
		- 동일성: **물리적**으로 같은 메모리에 있는 객체 인스턴인지 **참조값을 확인**하는 것.
				  == 비교
		- 동등성: **논리적**으로 같은지 확인하는 것. (회원 번호, 주민등록 번호)
					`equals()`메서드를 사용해서 비교
			- 각 클래스마다 동등성의 개념이 다르기 때문에 **equals()를 재정의 해야 한다.**
			  그렇지 않으면 **Object는 동일성 비교를 기본으로 제공한다.**
- [[불변 객체]]
	- 객체의 상태(객체 내부의 값, 필드, 멤버 변수)가 변하지 않는 객체
	- 기본형과 참조형의 공유
		- 기본형: 하나의 값을 여러 변수에서 **절대로 공유하지 않는다.**
		- 참조형: 하나의 객체를 참조값을 통해 여러 변수에서 **공유할 수 있다.**
	- 공유 참조와 사이드 이펙트
		- a,b는 같은 인스턴스를 참조하기 때문에 b의 값을 변경할 때
		  **a의 값도 부산으로 변경된다.**
		- 참조값의 공유를 막을 수 있는 방법이 없다.
	- 해결 방법
		- a와 b가 처음부터 **서로 다른 인스턴스를 참조**하면 된다.
		- 불변 객체(Immutable Object) 도입
			- 문제의 원인
				- 객체를 공유하는 것 자체는 문제가 아니다.
				- **공유된 객체의 값을 변경한 것이 문제다.**
			- 불변 객체: 객체의 상태가 변하지 않는 객체
			- 값을 변경할 수 없도록 `final` 키워드 선언
				- 값을 변경할 수 있는 **setter 메서드 제거**
				- **생성자를 통해서만 값을 변경**
				- 이후에는 **값을 변경하는 것이 불가능**
			- 사이드 이펙트가 발생하면 안되는 상황이라면
			  불변 객체를 만들어서 사용하면 된다.
			- 불변 객체의 **값을 변경하고 싶다면**
			  변경하고 싶은 값으로 **새로운 불변 객체를 생성해야 한다.**
	- 클래스를 불변으로 설계하는 이유 (지금은 원리를 이해하는 데 집중!)
		- 캐시 안정성
		- 멀티 쓰레드 안정성
		- 엔티티의 값 타입
- [[String 클래스]]
	- String 클래스는 내부 문자열 값을 비교하도록 e**quals() 메서드를 재정의** 해두었다.
		- 문자열 비교는 항상 `equals()`로 비교해야 한다.
	- String은 불변 객체이므로 생성 이후에 절대로 내부의 문자열 값을 변경할 수 없고,
	  변경이 필요한 경우 기존 값을 변경하지 않고, **새로운 결과를 만들어서 반환한다.**
		- 불변 객체로 설계되지 않았다면, 문자열 풀에서 같은 문자를 참조하는 변수의 모든 문자가 변경되는 사이드 이펙트가 발생했을 것이다.
	- StringBuilder
		- 불변인 String 클래스의 단점
			- 문자를 더하거나 변경할 때 마다 **계속해서 새로운 객체를 생성해야 한다.**
		- StringBuilder는 가변적이다.
			- 하나의 StringBuilder 객체 안에서 문자열을 추가, 삭제, 수정할 수 있고,
			  이때마다 **새로운 객체를 생성하지 않는다.**
			- StringBuilder는 보통 문자열을 변경하는 동안만 사용하다가 문자열 변경이 끝나면 안전한(불변) String으로 변경하는 것이 좋다.
- 래퍼(Wrapper) 클래스
	- 기본형의 한계
		- 객체가 아니다.
			- 객체 지향 프로그래밍의 장점을 살릴 수 없다.
				- 객체는 유용한 메서드를 제공할 수 있는데, **기본형은 메서드 제공 불가**
				- 객체 참조가 필요한 컬렉션 프레임워크와 제네릭을 사용할 수 없다.
		- null 값을 가질 수 없다.
			- **데이터가 "없음" 이라는 상태**를 나타내야할 필요가 있는데, 기본형은 항상 값을 가지기 때문에 **이런 표현을 할 수가 없다.**
	- 래퍼 클래스
		- 기본형을 객체로 감싸서 더 편리하게 사용하도록 도와주기 때문에 유용하다.
		- 불변이다.
		- 래퍼 클래스는 내부의 값을 비교하도록 **equals() 를 재정의 해두었다.**
		  따라서 값을 비교하려면 `equals()` 를 사용해야 한다.
	- 성능 비교
		- 기본형 연산이 래퍼 클래스보다 대략 5배 정도 빠른 것을 확인할 수 있다.
		- 기본형은 메모리에서 단순히 그 크기만큼의 공간을 차지한다.
			- 예를 들어 int 는 보통 4바이트의 메모리를 사용한다.
		- ![[Pasted image 20241124004929.png]]
- [[열거형(ENUM)]]
	- 